/*****************************************************************************/
Given a collection of distinct numbers, return all possible permutations.

For example,
[1,2,3] have the following permutations:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

注意：第一个字符与后面的某个位置的字符发生交换后，需要再次发生交换，不然顺序就会被打乱。
举个例子，在字符串abc中，在把第一个字符看成是a，后面的字符b、c看成一个整体的时候，
abc这个相对顺序不能改变，所以当b与c发生交换变成了acb之后，需要再次交换两个字符，重新回到abc。
/*****************************************************************************/

class Solution {
public:
	void getPermute(vector<int> &nums, int index, vector<vector<int>> &ret)
	{
	    if(index==(nums.size()-1))
		{
		    ret.push_back(nums);
		    return ;
		}
		for(int i=index; i<nums.size(); i++)
		{
			swap(nums[i], nums[index]);
			getPermute(nums, index+1, ret);
			swap(nums[i], nums[index]);
		}
	}

    	vector<vector<int>> permute(vector<int>& nums) {
        	vector<vector<int>> ret;
		if(nums.size()==0)
			return ret;
		getPermute(nums, 0, ret);
		return ret;
    	}
};
