/*******************************************************************************************/
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

For example,
If n = 4 and k = 2, a solution is:

[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

Note: 
两个数字n和k，找出所有这样的组合：
1.组合中有k个数字
2.组合是递增
3.组合中的数字是{1,2,3,....n} 的子集

那就是回溯了，对D中所有的数字进行k阶全排列，但这个全排列要排除非增序的组合。
/*******************************************************************************************/

class Solution {
public:
I. 
	void getCombine(int index, int n, int k, vector<int> &tmp, vector<vector<int>> &ret)
	{
		if(tmp.size()==k)
		{
			ret.push_back(tmp);
			return ;
		}
		if(tmp.size()>1 && tmp.back()<*(tmp.end()-2))  //递增
			return ;
		for(int i=index+1; i<n+1; i++)
		{
			tmp.push_back(i);
			getCombine(i, n, k, tmp, ret);
			tmp.pop_back();   //一次完成要弹出
		}
	}
II. 	
	void getCombine(int index, int n, int k, vector<int> &tmp, vector<vector<int>> &ret)
	{
		if(tmp.size()==k)
		{
			ret.push_back(tmp);
			return ;
		}
		if(tmp.size()>1 && tmp.back()<*(tmp.end()-2))
			return ;
		for(int i=index; i<n+1; i++)
		{
			tmp.push_back(i);
			getCombine(i+1, n, k, tmp, ret);
			tmp.pop_back();
		}
	}
	
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ret;
		if(n<k || !n || !k)
			return ret;
		vector<int> tmp;
		getCombine(0, n, k, tmp, ret);
		return ret;
    }
};
