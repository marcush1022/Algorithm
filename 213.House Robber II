/*******************************************************************************************/
Note: This is an extension of House Robber.

After robbing those houses on that street, the thief has found himself a new place for 
his thievery so that he will not get too much attention. 
This time, all houses at this place are arranged in a circle. 
That means the first house is the neighbor of the last one. Meanwhile, 
the security system for these houses remain the same as for those in the previous street.

Given a list of non-negative integers representing the amount of money of each house, 
determine the maximum amount of money you can rob tonight without alerting the police.

在一个序列中取数，不能连续取，求最大和（序列首位相连）。
/*******************************************************************************************/

class Solution
{
	public:
	//递推公式: dp[i]=max(dp[i-1], dp[i-2]+num[i])
	
	int doRob(vector<int> &nums, int begin, int end)
	{
		int ppre=0, pre=0, cur=0;
		for(int i=begin; i<end; i++)
		{
			cur=std::max(pre, ppre+nums[i]);
			ppre=pre;
			pre=cur;
		}
		return std::max(ppre, pre);
	}
	
	int rob(vector<int> &nums)
	{
		int begin=0, end=nums.size();
		if(end==1)
		    return nums[0];
		return std::max(doRob(nums, begin, end-1), doRob(nums, begin+1, end));
	}
};
