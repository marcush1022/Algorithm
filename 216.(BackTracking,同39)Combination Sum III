/*******************************************************************************************************************/
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be
used and each combination should be a unique set of numbers.


Example 1:

Input: k = 3, n = 7

Output:

[[1,2,4]]

Example 2:

Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]

Note: DFS, two conditions for basic case, one is sum , second is k number.
/*******************************************************************************************************************/

class Solution {
public:
	void getCombinationSum(int sum, int target, vector<int> &tmp, vector<vector<int>> &ret, int index, int k)
	{
		if(sum==target && tmp.size()==k)
		{
			ret.push_back(tmp);
			return ;
		}
		if(sum>target || tmp.size()>k)
			return ;
		for(int i=index; i<10; i++)
		{
			sum+=i;
			tmp.push_back(i);
			getCombinationSum(sum, target, tmp, ret, i+1, k);
			tmp.pop_back();
			sum-=i;
		}
	}
	
    	vector<vector<int>> combinationSum3(int k, int n) {
        	vector<vector<int>> ret;
		if(k<0 || n<0)
			return ret;
		vector<int> tmp;
		getCombinationSum(0, n, tmp, ret, 1, k);
		return ret;
    }
};
	
    	vector<vector<int>> combinationSum3(int k, int n) {
        	vector<vector<int>> ret;
		if(k<0 || n<0)
			return ret;
		vector<int> tmp;
		getCombinationSum(0, n, tmp, ret, 1, k);
		return ret;
    }
};
