/******************************************************************************************************/
Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.
/******************************************************************************************************/

class Solution {
public:
    TreeNode* build(vector<int> &preorder, vector<int> &inorder, int preindex, int inindex, int length)
	{
	    if(length<1)
	        return NULL;
		TreeNode *root=new TreeNode(preorder[preindex]);
		for(int i=0; i<length; i++)
		{
			if(root->val==inorder[i+inindex])
			{
				root->left=build(preorder, inorder, preindex+1, inindex, i);
				root->right=build(preorder, inorder, preindex+i+1, inindex+i+1, length-i-1);
				break;
			}
		}
		return root;
	}

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		return build(preorder, inorder, 0, 0, preorder.size());
        
    }
};
