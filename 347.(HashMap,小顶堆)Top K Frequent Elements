/**********************************************************************************************/
Given a non-empty array of integers, return the k most frequent elements.

For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].

Note: 
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
/**********************************************************************************************/

class Solution
{
	typedef pair<int, int> data;
	public:
	vector<int> topKFrequent(vector<int> &nums, int k)
	{
		int len=nums.size();
		if(len==0)
			return nums;
			
		unordered_map<int, int> m;
		priority_queue<data, vector<data>, greater<data>> heap;
		
		vector<int> ret;
		
		for(int i=0; i<len; i++)
			m[nums[i]]++;
		
		for(auto it=m.begin(); it!=m.end(); it++)
		{
			heap.push(make_pair(it->second, it->first));
			if(heap.size()>k)
				heap.pop();
		}
		
		while(!heap.empty())
		{
			ret.push_back(heap.top().second);
			heap.pop();
		}
		
		return ret;
	}
	
};
