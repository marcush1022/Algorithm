/******************************************************************************************************/
思路：这题是利用了quick-select的算法，也就是快速排序的partition，这个方法的理论时间复杂度是O(n)，是一种非常有用的工具．

使用分治每次将数组划分为两段，并且返回划分点的位置，如果这个位置恰好是我们要的第k大的数，那么返回这个数即可，

否则如果返回的位置小于要找的位置，则向右边的一半数组继续寻找

如果返回的位置大于要找的位置，则向左边寻找．
/******************************************************************************************************/

class Solution {  
public:  
    	int partition(vector<int>& nums, int left, int right)  
    	{  
        	int val=nums[right];
		for(int i=left; i<right; i++)
		{
			if(nums[i]<val)
				swap(nums[left++], nums[i]);
		}
		swap(nums[left], nums[right]);
		return left;
    	}  
      
    	int findKthLargest(vector<int>& nums, int k) 
	{  
		int len=nums.size();
		int pos=len-k, ans;
		int left=0,right=nums.size()-1;
		while((ans=partition(nums, left, right))!=pos)
		{
			if(ans<pos)
				left=ans+1;
			else
				right=ans-1;
		}
		
		return nums[len-k];
    }  
};  
